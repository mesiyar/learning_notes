##redis 启动:
  1. redis-cli &  直接后台启动
  2. redis-cli /xxx/xxx.conf 指定配置文件
##redis 设置密码:
1. 临时设置redis密码  在redis-cli 中执行 config set requirepass 密码
2. 永久性设置密码:在redis.conf 中找到requirepass 打开注释并设置对应密码即可

## redis 雪崩
如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。

这就是缓存雪崩：

Redis挂掉了，请求全部走数据库。对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！  
### 解决方案
1. 对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
2. 对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：
事发前：实现Redis的高可用(主从架构+Sentinel（哨兵） 或者Redis Cluster（集群）)，尽量避免Redis挂掉这种情况发生。
事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

## redis 穿透
请求的数据在缓存大量不命中，导致请求走数据库。缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！
### 解决方案
1. 布隆过滤 对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；
2. 缓存空对象 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

但是这种方法会存在两个问题：

如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；

即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响

# redis aof 和 rbd的区别
```
aof  类似mysql的binlog 将用户的每一条操作命令都记录下来
rbd  内存快照  
区别：aof 占用空间比较大 但是不会出现数据丢失
rbd 占用空间小，但是在突发停电时 会出现部分数据丢失
```
 
